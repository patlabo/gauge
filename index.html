<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Live PSI Gauge - Session Management</title>
    <!-- Load Tailwind CSS for modern, responsive styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom Font */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #0d1117; /* Dark background */
        }
        .gauge-display {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            line-height: 0.8; /* Tighten up line spacing for the large numbers */
        }
        .psi-unit {
            font-size: 2rem;
            color: #6b7280; /* Gray-500 */
            margin-top: -1.5rem; /* Pull unit closer to the number */
        }
        /* Ensure the body and html take up full height */
        html, body {
            height: 100%;
            margin: 0;
            overflow-y: auto; /* Allow scrolling for the main view */
            overflow-x: hidden;
        }
        
        /* Modal Backdrop Style */
        .modal-backdrop {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 20;
            display: none; /* Controlled by JS */
            align-items: center;
            justify-content: center;
        }
        
        /* Modal Content Style (The Session Panel) */
        .session-panel {
            background-color: #1f2937; /* Darker blue-gray */
            max-height: 90vh;
            width: 95%;
            max-width: 600px;
            overflow-y: auto;
        }
        
        /* --- LANDSCAPE FULL-SCREEN HIDING LOGIC --- */
        @media (orientation: landscape) {
            /* Base hidden state for header and controls in landscape mode */
            .hide-in-landscape {
                opacity: 0 !important;
                pointer-events: none !important; 
                visibility: hidden !important;
            }
            
            /* State applied by JS on tap */
            .show-in-landscape {
                opacity: 1 !important;
                pointer-events: auto !important; 
                visibility: visible !important;
            }
        }
        /* --- END LANDSCAPE LOGIC --- */
    </style>
</head>
<body class="text-white">

    <!-- Session Management Panel (Modal) -->
    <div id="sessionModalBackdrop" class="modal-backdrop">
        <div class="session-panel p-6 rounded-xl shadow-2xl transition-all duration-300 transform scale-95 opacity-0">
            <h2 class="text-2xl font-bold mb-4 text-blue-300 border-b border-gray-600 pb-2">All Recorded Sessions</h2>
            
            <p id="sessionListStatus" class="text-yellow-400 mb-4">Loading sessions from Firestore...</p>
            
            <div id="sessionsList" class="space-y-3 max-h-96 overflow-y-auto pr-2">
                <!-- Session items will be dynamically inserted here -->
            </div>
            
            <button onclick="closeSessionPanel()"
                    class="w-full mt-6 py-3 text-lg font-semibold rounded-xl transition-all duration-200 shadow-lg 
                           bg-gray-600 hover:bg-gray-700 active:scale-95">
                Close
            </button>
        </div>
    </div>
    <!-- End Session Management Panel -->


    <!-- Main Flex Container: Column layout, minimum full screen height -->
    <div id="mainAppContainer" class="flex flex-col min-h-screen p-4 pb-4 md:pb-8"> 
        
        <!-- HEADER CONTAINER (Hidden by default in landscape) -->
        <header id="headerContainer" class="text-center py-2 transition-opacity duration-300 hide-in-landscape">
            <h1 class="text-xl font-bold text-blue-400">PSI Gauge</h1>
            <p id="status" class="text-sm mt-1 text-yellow-500">
                Connection Status: Disconnected
            </p>
        </header>

        <!-- Main Gauge Display: flex-grow ensures it fills available space dynamically -->
        <main class="flex-grow gauge-display">
            <div class="p-8 rounded-xl shadow-2xl bg-gray-800 bg-opacity-50 gauge-card">
                <div class="overflow-x-auto"> 
                    <span id="psiValue" class="text-9xl md:text-[12rem] font-extrabold tracking-tight text-white transition-all duration-300 whitespace-nowrap">
                        --.-
                    </span>
                </div>
                <div class="psi-unit text-center">PSI</div>
            </div>
        </main>

        <!-- CONTROLS CONTAINER (Hidden by default in landscape) -->
        <div id="controlsContainer" class="p-2 pt-4 bg-gray-900 shadow-2xl border-t border-gray-700 z-10 w-full mx-auto max-w-lg rounded-t-xl transition-opacity duration-300 hide-in-landscape">
            <!-- Bluetooth Connect Button -->
            <button id="connectButton" onclick="requestDeviceAndConnect()"
                    class="w-full py-3 text-lg font-semibold rounded-xl transition-all duration-200 shadow-lg 
                           bg-blue-600 hover:bg-blue-700 active:scale-95">
                Connect to ESP32
            </button>
            
            <div class="flex space-x-3 mt-3">
                 <!-- Mock Data Button -->
                <button id="mockButton" onclick="toggleMockData()"
                        class="flex-1 py-2 text-base font-medium rounded-xl transition-all duration-200 shadow-lg 
                            bg-gray-700 hover:bg-gray-600 active:scale-95">
                    Mock Data
                </button>
                
                <!-- Start/Stop Logging Button -->
                <button id="startStopLogButton" onclick="toggleLogging()" disabled
                        class="flex-1 py-2 text-base font-medium rounded-xl transition-all duration-200 shadow-lg disabled:opacity-50
                            bg-orange-500 hover:bg-orange-600 active:scale-95">
                    Start Logging
                </button>
            </div>

            
            <!-- Data Log Status and Session Management Button -->
            <div class="mt-4 p-3 bg-gray-800 rounded-lg">
                <div id="sessionStatus" class="text-gray-400 text-sm space-y-1 flex flex-col">
                    <p id="logStatus" class="text-yellow-500 font-semibold">DB Status: Initializing...</p>
                    <p id="sessionCount" class="text-gray-500">Points: 0</p>
                </div>
                
                <!-- Session Management Button -->
                <button id="manageSessionsButton" onclick="openSessionPanel()" disabled
                        class="w-full mt-3 py-2 text-md font-medium rounded-xl transition-all duration-200 shadow-lg disabled:opacity-50
                            bg-green-600 hover:bg-green-700 active:scale-95">
                    Manage & Download Sessions
                </button>
                <p class="text-xs text-gray-500 mt-2 text-center">View all recorded sessions for easy export later.</p>
            </div>
        </div>
        
    </div>

    <script type="module">
        // Firebase Imports
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, collection, addDoc, query, where, getDocs, setLogLevel, limit, getCountFromServer, orderBy } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // IMPORTANT: Set Firestore logging level to Debug to see potential errors
        setLogLevel('debug'); 

        // ----------------------------------------------------------------------
        // CONFIGURATION FIREBASE PERSONNELLE
        // Ces valeurs ont été fournies par l'utilisateur à partir de la console Firebase.
        // ----------------------------------------------------------------------
        const FIREBASE_CONFIG = {
            apiKey: "AIzaSyCLqDL58iXAuWSzGYYwixSJoeA2_S4_LjY", 
            authDomain: "oil-pressure-gauge.firebaseapp.com",
            projectId: "oil-pressure-gauge", 
            storageBucket: "oil-pressure-gauge.firebasestorage.app",
            messagingSenderId: "459188403300",
            appId: "1:459188403300:web:25fe9f2a6b91ca3e493371"
        };
        // ----------------------------------------------------------------------


        // Global Firebase and App Variables
        let db;
        let auth;
        let userId;
        // Using the projectId as the app identifier for the storage path
        const appId = FIREBASE_CONFIG.projectId || 'manual-gauge-app'; 
        const LOG_COLLECTION_NAME = 'pressure_logs';

        // BLE Constants
        const NUS_SERVICE_UUID = '6e400001-b5a3-f393-e0a9-e50e24dcca9e';
        const RX_CHAR_UUID = '6e400003-b5a3-f393-e0a9-e50e24dcca9e'; 

        // State Variables
        let bleDevice = null;
        let rxCharacteristic = null;
        let mockDataInterval = null; 
        let isMockingData = false;
        let isLogging = false; 
        let currentMockPsi = 50.0; 
        let isAuthReady = false; // Auth flag is critical
        let currentSessionId = null; 
        let sessionDataPoints = 0; 
        let controlsVisible = false; // State for tap-to-show feature

        // UI Elements
        const psiValueElement = document.getElementById('psiValue');
        const statusElement = document.getElementById('status');
        const connectButton = document.getElementById('connectButton');
        const mockButton = document.getElementById('mockButton');
        const startStopLogButton = document.getElementById('startStopLogButton');
        const logStatusElement = document.getElementById('logStatus');
        const sessionCountElement = document.getElementById('sessionCount'); 
        const manageSessionsButton = document.getElementById('manageSessionsButton'); // New button
        const headerContainer = document.getElementById('headerContainer');
        const controlsContainer = document.getElementById('controlsContainer');
        const sessionModalBackdrop = document.getElementById('sessionModalBackdrop');
        const sessionPanelContent = sessionModalBackdrop.querySelector('.session-panel');
        const sessionsListElement = document.getElementById('sessionsList');
        const sessionListStatusElement = document.getElementById('sessionListStatus');
        
        // Tailwind color classes to manage
        const COLOR_CLASSES = ['text-white', 'text-yellow-400', 'text-orange-400', 'text-red-500'];

        // --- Utility Functions for Session Management ---

        /**
         * Opens the session management panel and loads all session IDs.
         */
        window.openSessionPanel = function() {
            if (!isAuthReady) {
                alert("Database is not ready. Please wait for initialization.");
                return;
            }
            
            // Show modal
            sessionModalBackdrop.style.display = 'flex';
            // Trigger animation
            setTimeout(() => {
                sessionPanelContent.classList.remove('scale-95', 'opacity-0');
                sessionPanelContent.classList.add('scale-100', 'opacity-100');
            }, 10);

            loadAllSessions();
        }

        /**
         * Closes the session management panel.
         */
        window.closeSessionPanel = function() {
            sessionPanelContent.classList.remove('scale-100', 'opacity-100');
            sessionPanelContent.classList.add('scale-95', 'opacity-0');
            
            setTimeout(() => {
                sessionModalBackdrop.style.display = 'none';
            }, 300); // Wait for transition
        }


        /**
         * Helper function to get the base path for user-specific logs.
         * @returns {string} The Firestore collection path.
         */
        function getLogCollectionPath() {
            // Path: /artifacts/{appId}/users/{userId}/pressure_logs
            return `/artifacts/${appId}/users/${userId}/${LOG_COLLECTION_NAME}`;
        }
        
        /**
         * Fetches a list of all unique Session IDs for the current user.
         */
        async function loadAllSessions() {
            sessionListStatusElement.textContent = "Loading sessions from Firestore...";
            sessionsListElement.innerHTML = '';
            
            if (!isAuthReady || !userId) {
                sessionListStatusElement.textContent = "Error: Authentication not complete.";
                return;
            }

            try {
                // 1. Get all documents and group by sessionId
                const logPath = getLogCollectionPath();
                const q = query(collection(db, logPath));
                
                const snapshot = await getDocs(q);
                const sessionsMap = {}; // Map to store {sessionId: {count: N, startTimestamp: T}}
                
                // Aggregate data to find unique sessions and count points
                snapshot.forEach(doc => {
                    const data = doc.data();
                    const sessionId = data.sessionId;
                    const timestamp = data.timestamp;

                    if (!sessionsMap[sessionId]) {
                        // Use the sessionId (which is the start timestamp) as the unique ID
                        sessionsMap[sessionId] = { 
                            count: 0, 
                            sessionId: sessionId, 
                            startTimestamp: Number(sessionId) // The sessionId is the starting timestamp
                        };
                    }
                    sessionsMap[sessionId].count++;
                });

                const sessionList = Object.values(sessionsMap).sort((a, b) => b.startTimestamp - a.startTimestamp);
                
                if (sessionList.length === 0) {
                    sessionListStatusElement.textContent = "No sessions recorded yet.";
                    return;
                }

                // 2. Render the list
                sessionListStatusElement.textContent = `${sessionList.length} total sessions found.`;
                
                sessionList.forEach(session => {
                    const sessionDate = new Date(session.startTimestamp).toLocaleString();
                    const item = document.createElement('div');
                    item.className = 'flex justify-between items-center p-3 bg-gray-700 rounded-lg hover:bg-gray-600 cursor-pointer transition-colors duration-150 shadow-md';
                    item.innerHTML = `
                        <div class="flex flex-col">
                            <span class="text-white font-semibold text-base">${sessionDate}</span>
                            <span class="text-gray-400 text-xs">Points: ${session.count}</span>
                        </div>
                        <button data-session-id="${session.sessionId}" 
                                class="download-btn bg-green-500 hover:bg-green-600 text-white text-sm py-1 px-3 rounded-md transition-colors duration-150">
                            Download CSV
                        </button>
                    `;
                    sessionsListElement.appendChild(item);
                });

                // 3. Attach click handlers to the new download buttons
                sessionsListElement.querySelectorAll('.download-btn').forEach(button => {
                    button.addEventListener('click', (e) => {
                        const sessionId = e.target.getAttribute('data-session-id');
                        exportSessionLog(sessionId);
                    });
                });

            } catch (error) {
                console.error("Error loading sessions:", error);
                sessionListStatusElement.textContent = "Error loading sessions. Check console for details.";
            }
        }


        /**
         * Fetches all documents for the specified session ID and exports them as CSV.
         * @param {string} sessionIdToExport - The full Session ID (timestamp string) to retrieve.
         */
        window.exportSessionLog = async function(sessionIdToExport) {
            
            // Disable the panel buttons temporarily
            sessionsListElement.querySelectorAll('.download-btn').forEach(btn => {
                btn.disabled = true;
                if (btn.getAttribute('data-session-id') === sessionIdToExport) {
                    btn.textContent = "Downloading...";
                }
            });

            if (!isAuthReady || !userId || isLogging) {
                console.error("Cannot export: Auth not ready or logging is active.");
                alert("Cannot export: Please stop logging and ensure the database is ready.");
                // Re-enable buttons if error occurs
                sessionsListElement.querySelectorAll('.download-btn').forEach(btn => btn.disabled = false);
                return;
            }

            const logPath = getLogCollectionPath();
            // CRITICAL: Query MUST use the exact sessionId
            const q = query(collection(db, logPath), where("sessionId", "==", sessionIdToExport));
            
            try {
                const snapshot = await getDocs(q);
                let csvContent = "Timestamp (ISO),Time (Local),PSI\n";
                let downloadedCount = 0;
                
                snapshot.forEach(doc => {
                    const data = doc.data();
                    const date = new Date(data.timestamp);
                    const isoTime = date.toISOString();
                    // Local time for easy reading
                    const localTime = date.toLocaleTimeString('en-US', { hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit', fractionalSecondDigits: 3 });
                    
                    csvContent += `${isoTime},${localTime},${data.psi.toFixed(2)}\n`;
                    downloadedCount++;
                });

                if (downloadedCount === 0) {
                     sessionListStatusElement.textContent = `No data found for session ${sessionIdToExport}.`;
                } else {
                    
                    // 1. Trigger the download 
                    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
                    // Filename is based on the session ID (the starting timestamp)
                    const fileName = `PSI_Log_${new Date(Number(sessionIdToExport)).toISOString().slice(0, 19).replace('T', '_')}.csv`;
                    
                    const link = document.createElement('a');
                    link.href = URL.createObjectURL(blob);
                    link.setAttribute('download', fileName);
                    link.style.visibility = 'hidden';
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    
                    // 2. Update Status
                    sessionListStatusElement.textContent = `Downloaded ${downloadedCount} points for session ${sessionIdToExport}.`;
                }
                
            } catch (error) {
                console.error("CSV Export Error:", error);
                sessionListStatusElement.textContent = "CSV Export Failed!";
            }
            
            // Re-enable buttons
            sessionsListElement.querySelectorAll('.download-btn').forEach(btn => {
                btn.disabled = false;
                if (btn.getAttribute('data-session-id') === sessionIdToExport) {
                    btn.textContent = "Download CSV";
                }
            });
            
            // Close panel after success/failure
            closeSessionPanel();
        }

        // --- Layout and BLE/Mock Code (mostly unchanged) ---

        /**
         * Checks if the device is currently in landscape orientation.
         */
        function isLandscape() {
            // Uses standard window property to detect orientation
            return window.matchMedia("(orientation: landscape)").matches;
        }

        /**
         * Toggles the visibility of the header and control panel on tap, but ONLY in landscape mode.
         */
        function toggleControlsOnTap(event) {
            if (!isLandscape() || sessionModalBackdrop.style.display === 'flex') {
                return;
            }

            if (controlsContainer.contains(event.target) || headerContainer.contains(event.target)) {
                return;
            }
            
            controlsVisible = !controlsVisible;

            const elements = [headerContainer, controlsContainer];
            const showClass = 'show-in-landscape';
            const hideClass = 'hide-in-landscape';

            if (controlsVisible) {
                elements.forEach(el => {
                    el.classList.remove(hideClass);
                    el.classList.add(showClass);
                });
            } else {
                elements.forEach(el => {
                    el.classList.remove(showClass);
                    el.classList.add(hideClass);
                });
            }
        }
        
        /**
         * Re-applies the default landscape hiding logic if the orientation changes back 
         */
        function checkOrientationLayout() {
            const elements = [headerContainer, controlsContainer];
            const showClass = 'show-in-landscape';
            const hideClass = 'hide-in-landscape';
            
            if (isLandscape()) {
                if (!controlsVisible) {
                    elements.forEach(el => {
                        el.classList.remove(showClass);
                        el.classList.add(hideClass);
                    });
                }
            } else {
                controlsVisible = true;
                 elements.forEach(el => {
                    el.classList.remove(hideClass);
                    el.classList.remove(showClass);
                });
            }
        }
        
        window.addEventListener('resize', checkOrientationLayout);
        document.body.addEventListener('click', toggleControlsOnTap);


        /**
         * Initialize Firebase and perform custom authentication.
         */
        async function initializeFirebase() {
            logStatusElement.textContent = "DB Status: Connecting...";

            try {
                if (!FIREBASE_CONFIG.apiKey || !FIREBASE_CONFIG.projectId) {
                    throw new Error("Missing Firebase Credentials. Please update FIREBASE_CONFIG in the script.");
                }

                const app = initializeApp(FIREBASE_CONFIG);
                db = getFirestore(app);
                auth = getAuth(app);
                
                // IMPORTANT: Use signInAnonymously if no __initial_auth_token is provided
                await signInAnonymously(auth);
                
                userId = auth.currentUser?.uid || crypto.randomUUID();
                isAuthReady = true;
                
                logStatusElement.textContent = `DB Status: Ready (User ${userId.substring(0, 4)}...)`;
                logStatusElement.classList.remove('text-red-500', 'text-yellow-500');
                logStatusElement.classList.add('text-green-500');

                // Enable the session management button
                manageSessionsButton.disabled = false;
                
                if (bleDevice || isMockingData) {
                    startStopLogButton.disabled = false;
                }

            } catch (error) {
                console.error("Firebase Initialization or Auth Error:", error);
                
                let displayError = "DB Status: ERROR";
                if (error.message.includes("Missing Firebase Credentials")) {
                    displayError = "DB Status: CRITICAL CONFIG ERROR";
                }

                connectButton.disabled = false;
                mockButton.disabled = false;
                
                logStatusElement.textContent = displayError;
                logStatusElement.classList.remove('text-green-500');
                logStatusElement.classList.add('text-red-500');

                isAuthReady = false;
                startStopLogButton.disabled = true;
                manageSessionsButton.disabled = true;
            }
        }

        /**
         * Toggles the data logging state on/off.
         */
        window.toggleLogging = function() {
            if (!isAuthReady) {
                logStatusElement.textContent = "DB Status: Not Ready";
                return;
            }

            if (!bleDevice && !isMockingData) {
                updateStatus("Error: Start data stream first.", true);
                return;
            }
            
            isLogging = !isLogging;
            
            if (isLogging) {
                // START LOGGING: Create a new session ID (the current timestamp)
                currentSessionId = Date.now().toString(); 
                sessionDataPoints = 0; 
                
                startStopLogButton.textContent = "Stop Logging";
                startStopLogButton.classList.remove('bg-orange-500', 'hover:bg-orange-600');
                startStopLogButton.classList.add('bg-red-600', 'hover:bg-red-700');
                
                logStatusElement.textContent = `DB Status: Recording Session...`;
                logStatusElement.classList.remove('text-green-500', 'text-red-500', 'text-yellow-500');
                logStatusElement.classList.add('text-blue-400'); // Blue for active recording
                
                updateStatus("LIVE - Recording");
                console.log(`[LOGGING] Session started: ${currentSessionId}`); 

            } else {
                // STOP LOGGING
                startStopLogButton.textContent = "Start Logging";
                startStopLogButton.classList.remove('bg-red-600', 'hover:bg-red-700');
                startStopLogButton.classList.add('bg-orange-500', 'hover:bg-orange-600');
                
                logStatusElement.textContent = `DB Status: Logged ${sessionDataPoints} points (ID: ${currentSessionId.substring(4)}...).`;
                logStatusElement.classList.remove('text-blue-400', 'text-red-500');
                logStatusElement.classList.add('text-green-500');

                sessionCountElement.textContent = `Points: ${sessionDataPoints} logged`;

                updateStatus("LIVE - Stopped Logging");
                console.log(`[LOGGING] Session finished. Total points: ${sessionDataPoints}`); 
                currentSessionId = null; // Clear session ID
            }
        }

        /**
         * Saves a pressure reading to Firestore.
         * @param {number} psiValue - The pressure value (PSI).
         */
        async function logPressureReading(psiValue) {
            if (!isAuthReady || !userId || !currentSessionId) {
                return;
            }
            
            const logPath = getLogCollectionPath();

            try {
                // We don't use the timestamp for the sessionId, we use the one created at toggleLogging start
                addDoc(collection(db, logPath), {
                    psi: psiValue,
                    timestamp: Date.now(), 
                    sessionId: currentSessionId, 
                }).then(() => {
                    sessionDataPoints++; 
                    if (isLogging) {
                        sessionCountElement.textContent = `Points: ${sessionDataPoints}`;
                    }
                }).catch(error => {
                    console.error("CRITICAL ERROR writing document to Firestore (Check Security Rules!):", error); 
                });
                
            } catch (error) {
                console.error("Synchronous logPressureReading Error:", error);
            }
        }

        /**
         * Utility to update the status text and optionally log messages.
         */
        function updateStatus(text, isError = false, isMock = false) {
            console.log(text);
            statusElement.textContent = `Connection Status: ${text}`;
            if (isMock) {
                statusElement.className = 'text-sm mt-1 text-purple-400';
            } else {
                statusElement.className = `text-sm mt-1 ${isError ? 'text-red-500' : 'text-green-500'}`;
            }
        }

        /**
         * Core function to update the display based on received data.
         */
        function updateGaugeDisplay(dataString) {
            const psi = parseFloat(dataString.trim());
            
            if (!isNaN(psi)) {
                psiValueElement.textContent = psi.toFixed(1); 
                
                // 1. Remove all color classes first
                psiValueElement.classList.remove(...COLOR_CLASSES);
                
                // 2. Apply color based on new thresholds
                if (psi <= 10) {
                    psiValueElement.classList.add('text-red-500');
                } else if (psi <= 30) {
                    psiValueElement.classList.add('text-orange-400');
                } else if (psi <= 40) {
                    psiValueElement.classList.add('text-yellow-400');
                } else {
                    psiValueElement.classList.add('text-white');
                }
                
                if (isLogging) {
                    logPressureReading(psi);
                }
            }
        }
        
        function handleCharacteristicValueChanged(event) {
            const value = event.target.value;
            const decoder = new TextDecoder('utf-8');
            const dataString = decoder.decode(value);
            updateGaugeDisplay(dataString);
        }

        window.toggleMockData = function() {
            if (isMockingData) {
                clearInterval(mockDataInterval);
                isMockingData = false;
                mockButton.textContent = "Mock Data";
                mockButton.classList.remove('bg-red-600', 'hover:bg-red-700');
                mockButton.classList.add('bg-gray-700', 'hover:bg-gray-600');
                updateGaugeDisplay('--.-');
                updateStatus("Disconnected");
                connectButton.disabled = false;
                startStopLogButton.disabled = true;
                if (isLogging) toggleLogging();

            } else {
                if (bleDevice && bleDevice.gatt.connected) {
                    updateStatus("Error: Disconnect real device first.", true);
                    return;
                }
                isMockingData = true;
                mockButton.textContent = "Stop Mocking";
                mockButton.classList.remove('bg-gray-700', 'hover:bg-gray-600');
                mockButton.classList.add('bg-red-600', 'hover:bg-red-700');
                connectButton.disabled = true;
                
                startStopLogButton.disabled = !isAuthReady;
                
                updateStatus("MOCK Data Running", false, true);

                mockDataInterval = setInterval(() => {
                    const delta = (Math.random() * 2) - 1;
                    currentMockPsi = Math.max(0, Math.min(150, currentMockPsi + delta));
                    
                    updateGaugeDisplay(currentMockPsi.toFixed(1));
                }, 100);
            }
        }
        
        window.requestDeviceAndConnect = async function() {
            if (isMockingData) {
                updateStatus("Error: Stop mock data first.", true);
                return;
            }

            if (!navigator.bluetooth) {
                updateStatus("Error: Web Bluetooth not supported.", true);
                return;
            }

            try {
                updateStatus("Scanning...");
                connectButton.disabled = true;
                connectButton.textContent = "Scanning...";
                mockButton.disabled = true;
                
                bleDevice = await navigator.bluetooth.requestDevice({
                    filters: [{ services: [NUS_SERVICE_UUID] }],
                });
                
                bleDevice.addEventListener('gattserverdisconnected', onDisconnected);
                
                updateStatus(`Connecting to ${bleDevice.name}...`);
                await connectGATT();

            } catch (error) {
                updateStatus(`Connection Error`, true);
                connectButton.disabled = false;
                connectButton.textContent = "Connect to ESP32";
                mockButton.disabled = false;
            }
        }

        async function connectGATT() {
            try {
                const server = await bleDevice.gatt.connect();
                updateStatus("Connected. Discovering services...");
                
                const service = await server.getPrimaryService(NUS_SERVICE_UUID);
                updateStatus("Service found. Discovering characteristic...");

                rxCharacteristic = await service.getCharacteristic(RX_CHAR_UUID);
                updateStatus("Subscribing to data stream...");

                await rxCharacteristic.startNotifications();
                rxCharacteristic.addEventListener('characteristicvaluechanged', handleCharacteristicValueChanged);

                updateStatus("CONNECTED (LIVE)");
                statusElement.className = 'text-sm mt-1 text-green-500';
                
                connectButton.textContent = "CONNECTED";
                connectButton.disabled = true;
                mockButton.disabled = true;

                startStopLogButton.disabled = !isAuthReady;

            } catch (error) {
                updateStatus(`GATT Error: ${error.message}`, true);
                connectButton.disabled = false;
                connectButton.textContent = "Connect to ESP32";
                mockButton.disabled = false;
                startStopLogButton.disabled = true;
                if (bleDevice && bleDevice.gatt.connected) {
                    bleDevice.gatt.disconnect();
                }
            }
        }

        function onDisconnected() {
            updateStatus(`Disconnected. Reconnecting...`, true);
            psiValueElement.textContent = '--.-';
            connectButton.disabled = false;
            connectButton.textContent = "Connect to ESP32";
            mockButton.disabled = false;
            startStopLogButton.disabled = true;
            if (isLogging) toggleLogging();

            setTimeout(async () => {
                 if (bleDevice) {
                    try {
                        updateStatus("Reconnecting...");
                        await connectGATT();
                    } catch (error) {
                        updateStatus(`Disconnected`, true);
                        connectButton.disabled = false;
                        connectButton.textContent = "Connect to ESP32";
                        mockButton.disabled = false;
                    }
                }
            }, 2000);
        }

        // --- Initialization on load ---
        window.onload = () => {
            initializeFirebase();
            connectButton.disabled = false;
            mockButton.disabled = false; 
            
            psiValueElement.textContent = '--.-';
            updateStatus("Ready to connect");
            
            checkOrientationLayout();
        };

    </script>
</body>
</html>
