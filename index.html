<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Live PSI Gauge with Session Logging and CSV Export</title>
    <!-- Load Tailwind CSS for modern, responsive styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom Font */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #0d1117; /* Dark background */
        }
        .gauge-display {
            /* Ensures text takes up most of the screen vertically */
            min-height: 40vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            line-height: 0.8; /* Tighten up line spacing for the large numbers */
        }
        .psi-unit {
            font-size: 2rem;
            color: #6b7280; /* Gray-500 */
            margin-top: -1.5rem; /* Pull unit closer to the number */
        }
        /* FIX: Removed sticky position from controls.
           Instead, the main container now has a large bottom padding (pb-40) 
           to reserve space, preventing overlap when scrolling or zooming. */
        .controls {
            padding: 1rem 0;
        }
        .log-entry {
            border-bottom: 1px solid #1f2937; /* Gray-800 */
            padding: 0.5rem 0;
        }
    </style>
</head>
<!-- ADDED large padding-bottom (pb-40) to the main container to ensure 
     the gauge display is pushed above the fixed control area's height. -->
<body class="text-white">
    <div class="flex flex-col min-h-screen p-4 pb-40"> 
        
        <header class="text-center py-6">
            <h1 class="text-2xl font-bold text-blue-400">ESP32 Live Pressure Gauge</h1>
            <p id="status" class="text-sm mt-1 text-yellow-500">
                Connection Status: Disconnected
            </p>
            <p class="text-xs mt-1 text-gray-400">
                Open with Bluefy or another Web Bluetooth-enabled browser on iOS.
            </p>
        </header>

        <!-- Main Gauge Display -->
        <main class="flex-grow gauge-display">
            <div class="p-8 rounded-xl shadow-2xl bg-gray-800 bg-opacity-50">
                <span id="psiValue" class="text-9xl md:text-[12rem] font-extrabold tracking-tight text-white transition-all duration-300">
                    --.-
                </span>
                <div class="psi-unit text-center">PSI</div>
            </div>
        </main>

        <!-- Controls and Logs -->
        <!-- This entire section is now positioned after the main content, 
             and the main container's padding ensures the content above is visible. -->
        <div class="absolute bottom-0 left-0 right-0 p-4 bg-gray-900 shadow-2xl border-t border-gray-700">
            <!-- Bluetooth Connect Button -->
            <button id="connectButton" onclick="requestDeviceAndConnect()"
                    class="w-full py-4 text-xl font-semibold rounded-xl transition-all duration-200 shadow-lg 
                           bg-blue-600 hover:bg-blue-700 active:scale-95">
                Connect to ESP32 Gauge
            </button>
            
            <div class="flex space-x-3 mt-3">
                 <!-- Mock Data Button -->
                <button id="mockButton" onclick="toggleMockData()"
                        class="flex-1 py-3 text-lg font-medium rounded-xl transition-all duration-200 shadow-lg 
                            bg-gray-700 hover:bg-gray-600 active:scale-95">
                    Mock Data
                </button>
                
                <!-- NEW: Start/Stop Logging Button -->
                <button id="startStopLogButton" onclick="toggleLogging()" disabled
                        class="flex-1 py-3 text-lg font-medium rounded-xl transition-all duration-200 shadow-lg disabled:opacity-50
                            bg-orange-500 hover:bg-orange-600 active:scale-95">
                    Start Logging
                </button>
            </div>

            
            <!-- Data Log Status and Export -->
            <div class="mt-4 p-3 bg-gray-800 rounded-lg">
                <div id="sessionStatus" class="text-gray-400 text-sm space-y-1 flex justify-between items-center">
                    <p id="logStatus" class="text-yellow-500">Initializing database...</p>
                    <p id="sessionCount" class="text-gray-500">Points: 0</p>
                </div>
                
                <!-- Export Button (Hidden until a session is stopped) -->
                <button id="exportButton" onclick="exportSessionLog()" disabled
                        class="w-full mt-3 py-2 text-md font-medium rounded-xl transition-all duration-200 shadow-lg disabled:opacity-50
                            bg-green-600 hover:bg-green-700 active:scale-95">
                    Download Log (.csv)
                </button>
            </div>
        </div>
    </div>

    <script type="module">
        // Firebase Imports
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, collection, addDoc, query, where, getDocs, setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // IMPORTANT: Set Firestore logging level to Debug to see potential errors
        setLogLevel('debug'); 

        // Global Firebase and App Variables
        let db;
        let auth;
        let userId;
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const LOG_COLLECTION_NAME = 'pressure_logs';

        // BLE Constants
        const NUS_SERVICE_UUID = '6e400001-b5a3-f393-e0a9-e50e24dcca9e';
        const RX_CHAR_UUID = '6e400003-b5a3-f393-e0a9-e50e24dcca9e'; 

        // State Variables
        let bleDevice = null;
        let rxCharacteristic = null;
        let mockDataInterval = null; 
        let isMockingData = false;
        let isLogging = false; 
        let currentMockPsi = 50.0; 
        let isAuthReady = false; // Auth flag is critical
        let currentSessionId = null; 
        let sessionDataPoints = 0; 

        // UI Elements
        const psiValueElement = document.getElementById('psiValue');
        const statusElement = document.getElementById('status');
        const connectButton = document.getElementById('connectButton');
        const mockButton = document.getElementById('mockButton');
        const startStopLogButton = document.getElementById('startStopLogButton');
        const logStatusElement = document.getElementById('logStatus');
        const sessionCountElement = document.getElementById('sessionCount'); 
        const exportButton = document.getElementById('exportButton'); 

        /**
         * Initialize Firebase and perform custom authentication.
         */
        async function initializeFirebase() {
            logStatusElement.textContent = "Connecting to database...";

            try {
                const firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : '{}');
                const app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);
                
                // AUTHENTICATION
                if (typeof __initial_auth_token !== 'undefined') {
                    await signInWithCustomToken(auth, __initial_auth_token);
                } else {
                    await signInAnonymously(auth);
                }
                
                // Once authenticated, set user ID and ready flag
                userId = auth.currentUser?.uid || crypto.randomUUID();
                isAuthReady = true;
                
                logStatusElement.textContent = `DB Ready. User ID: ${userId.substring(0, 8)}...`;
                sessionCountElement.textContent = "Points: 0";
                
                // If a stream is active (mock or BLE), enable the logging button
                if (bleDevice || isMockingData) {
                    startStopLogButton.disabled = false;
                }

            } catch (error) {
                console.error("Firebase Initialization or Auth Error:", error);
                logStatusElement.textContent = `Database Error: Failed to connect (${error.message.substring(0, 30)}...).`;
                isAuthReady = false;
            }
        }

        /**
         * Toggles the data logging state on/off.
         */
        window.toggleLogging = function() {
            if (!isAuthReady) {
                alert("Database is not ready. Please wait for DB Ready status.");
                return;
            }

            if (!bleDevice && !isMockingData) {
                updateStatus("Error: Start a data stream (live or mock) before logging.", true);
                return;
            }
            
            isLogging = !isLogging;
            
            if (isLogging) {
                // START LOGGING: Create a new session ID
                currentSessionId = Date.now().toString(); 
                sessionDataPoints = 0; 
                exportButton.disabled = true;
                
                startStopLogButton.textContent = "Stop Logging";
                startStopLogButton.classList.remove('bg-orange-500', 'hover:bg-orange-600');
                startStopLogButton.classList.add('bg-red-600', 'hover:bg-red-700');
                
                logStatusElement.textContent = `Recording Session ${currentSessionId.slice(-4)}...`;
                updateStatus("Data LOGGING STARTED", false, true);
                console.log(`[LOGGING] Session started: ${currentSessionId}`); 

            } else {
                // STOP LOGGING
                startStopLogButton.textContent = "Start Logging";
                startStopLogButton.classList.remove('bg-red-600', 'hover:bg-red-700');
                startStopLogButton.classList.add('bg-orange-500', 'hover:bg-orange-600');
                
                logStatusElement.textContent = `Session ${currentSessionId.slice(-4)} FINISHED.`;
                sessionCountElement.textContent = `Points: ${sessionDataPoints} logged`;

                exportButton.disabled = (sessionDataPoints === 0); // Only enable export if points were logged
                updateStatus("Data Logging STOPPED. Stream still running.");
                console.log(`[LOGGING] Session finished. Total points: ${sessionDataPoints}`); 
            }
        }

        /**
         * Saves a pressure reading to Firestore.
         * @param {number} psiValue - The pressure value (PSI).
         */
        async function logPressureReading(psiValue) {
            // CRITICAL CHECK: Ensure auth is ready before attempting to save
            if (!isAuthReady || !userId || !currentSessionId) {
                console.warn("Attempted to log data: Auth or Session ID not ready. Dropping point.");
                return;
            }
            
            const logPath = `/artifacts/${appId}/users/${userId}/${LOG_COLLECTION_NAME}`;

            try {
                // We do NOT await this addDoc to prevent blocking the main thread 
                // and preserve high log rate. We use .then() for count update.
                addDoc(collection(db, logPath), {
                    psi: psiValue,
                    timestamp: Date.now(), 
                    sessionId: currentSessionId, 
                }).then(() => {
                    sessionDataPoints++; // Increment count only on successful save
                    if (isLogging) {
                        sessionCountElement.textContent = `Points: ${sessionDataPoints}`;
                    }
                }).catch(error => {
                    console.error("CRITICAL ERROR writing document to Firestore:", error); 
                    logStatusElement.textContent = `CRITICAL LOGGING ERROR! Check console.`;
                });
                
            } catch (error) {
                // This catch block handles synchronous errors only (e.g., if db or logPath are invalid)
                console.error("Synchronous logPressureReading Error:", error);
            }
        }

        /**
         * Fetches all documents for the last completed session and exports them as CSV.
         */
        window.exportSessionLog = async function() {
            if (!currentSessionId) {
                alert("No session was recorded or the last session was not properly closed.");
                return;
            }
            if (!isAuthReady) {
                 alert("Database initialization not complete. Please wait for DB Ready status.");
                return;
            }

            exportButton.disabled = true;
            exportButton.textContent = "Fetching Data...";
            
            const exportId = currentSessionId;
            const logPath = `/artifacts/${appId}/users/${userId}/${LOG_COLLECTION_NAME}`;
            
            // Query for all documents matching the completed session ID
            const q = query(collection(db, logPath), where("sessionId", "==", exportId));
            
            try {
                const snapshot = await getDocs(q);
                let csvContent = "Timestamp (ISO),Time (Local),PSI\n";
                
                snapshot.forEach(doc => {
                    const data = doc.data();
                    const date = new Date(data.timestamp);
                    const isoTime = date.toISOString();
                    const localTime = date.toLocaleTimeString('en-US', { hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit', fractionalSecondDigits: 3 });
                    
                    csvContent += `${isoTime},${localTime},${data.psi.toFixed(2)}\n`;
                });

                if (snapshot.docs.length === 0) {
                     // Use a custom modal instead of alert
                     console.error("Fetch successful, but 0 points found for this session. The data failed to write during logging.");
                     exportButton.textContent = "0 Points Fetched!";
                } else {
                    // Create a blob and trigger download
                    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
                    const fileName = `PSI_Log_${new Date(Number(exportId)).toISOString().slice(0, 19).replace('T', '_')}.csv`;
                    
                    // Use a temporary link to trigger the download on the mobile device
                    const link = document.createElement('a');
                    link.href = URL.createObjectURL(blob);
                    link.setAttribute('download', fileName);
                    link.style.visibility = 'hidden';
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);

                    exportButton.textContent = `Download Successful! (${snapshot.docs.length} points)`;
                }
                
            } catch (error) {
                console.error("CSV Export Error:", error);
                exportButton.textContent = "Export Failed!";
            }
            
            // Re-enable the button after a delay
            setTimeout(() => {
                if (!isLogging) {
                    exportButton.disabled = false;
                    exportButton.textContent = "Download Log (.csv)";
                }
            }, 3000);
        }

        /**
         * Utility to update the status text and optionally log messages.
         */
        function updateStatus(text, isError = false, isMock = false) {
            console.log(text);
            statusElement.textContent = `Connection Status: ${text}`;
            if (isMock) {
                statusElement.className = 'text-sm mt-1 text-purple-400';
            } else {
                statusElement.className = `text-sm mt-1 ${isError ? 'text-red-500' : 'text-yellow-500'}`;
            }
        }

        /**
         * Core function to update the display based on received data.
         */
        function updateGaugeDisplay(dataString) {
            const psi = parseFloat(dataString.trim());
            
            if (!isNaN(psi)) {
                psiValueElement.textContent = psi.toFixed(1); 
                
                // Optional: Change gauge color based on pressure
                if (psi > 120) {
                    psiValueElement.classList.remove('text-yellow-400', 'text-white');
                    psiValueElement.classList.add('text-red-500');
                } else if (psi > 80) {
                    psiValueElement.classList.remove('text-red-500', 'text-white');
                    psiValueElement.classList.add('text-yellow-400');
                } else {
                    psiValueElement.classList.remove('text-red-500', 'text-yellow-400');
                    psiValueElement.classList.add('text-white');
                }
                
                // --- Conditional Logging: Only log if the user has enabled it ---
                if (isLogging) {
                    logPressureReading(psi);
                }
            }
        }
        
        // --- Bluetooth connection functions and Mock Data functions remain the same ---
        function handleCharacteristicValueChanged(event) {
            const value = event.target.value;
            const decoder = new TextDecoder('utf-8');
            const dataString = decoder.decode(value);
            updateGaugeDisplay(dataString);
        }

        window.toggleMockData = function() {
            if (isMockingData) {
                clearInterval(mockDataInterval);
                isMockingData = false;
                mockButton.textContent = "Mock Data";
                mockButton.classList.remove('bg-red-600', 'hover:bg-red-700');
                mockButton.classList.add('bg-gray-700', 'hover:bg-gray-600');
                updateGaugeDisplay('--.-');
                updateStatus("Mock Data Stopped. Ready to connect.");
                connectButton.disabled = false;
                startStopLogButton.disabled = true;
                if (isLogging) toggleLogging();

            } else {
                if (bleDevice && bleDevice.gatt.connected) {
                    updateStatus("Error: Disconnect real device before running mock data.", true);
                    return;
                }
                isMockingData = true;
                mockButton.textContent = "Stop Mocking";
                mockButton.classList.remove('bg-gray-700', 'hover:bg-gray-600');
                mockButton.classList.add('bg-red-600', 'hover:bg-red-700');
                connectButton.disabled = true;
                
                // Only enable logging if DB is ready
                startStopLogButton.disabled = !isAuthReady;
                
                updateStatus("Mock Data Running (Simulating PSI)", false, true);

                mockDataInterval = setInterval(() => {
                    const delta = (Math.random() * 2) - 1;
                    currentMockPsi = Math.max(0, Math.min(150, currentMockPsi + delta));
                    
                    updateGaugeDisplay(currentMockPsi.toFixed(1));
                }, 100);
            }
        }
        
        window.requestDeviceAndConnect = async function() {
            if (isMockingData) {
                updateStatus("Mock data is running. Please stop it before connecting to Bluetooth.", true);
                return;
            }

            if (!navigator.bluetooth) {
                updateStatus("Error: Web Bluetooth not supported in this browser.", true);
                console.error("Web Bluetooth is not supported in this browser. Please use Bluefy.");
                return;
            }

            try {
                updateStatus("Requesting device access...");
                connectButton.disabled = true;
                connectButton.textContent = "Scanning...";
                mockButton.disabled = true;
                
                bleDevice = await navigator.bluetooth.requestDevice({
                    filters: [{ services: [NUS_SERVICE_UUID] }],
                });
                
                bleDevice.addEventListener('gattserverdisconnected', onDisconnected);
                
                updateStatus(`Found device: ${bleDevice.name}. Connecting...`);
                await connectGATT();

            } catch (error) {
                updateStatus(`Connection Error: ${error.message}`, true);
                connectButton.disabled = false;
                connectButton.textContent = "Connect to ESP32 Gauge";
                mockButton.disabled = false;
            }
        }

        async function connectGATT() {
            try {
                const server = await bleDevice.gatt.connect();
                updateStatus("Connected to GATT server. Discovering services...");
                
                const service = await server.getPrimaryService(NUS_SERVICE_UUID);
                updateStatus("Discovered NUS service. Discovering characteristics...");

                rxCharacteristic = await service.getCharacteristic(RX_CHAR_UUID);
                updateStatus("Discovered RX characteristic. Subscribing to notifications...");

                await rxCharacteristic.startNotifications();
                rxCharacteristic.addEventListener('characteristicvaluechanged', handleCharacteristicValueChanged);

                updateStatus("Subscribed to data stream (LIVE)", false);
                statusElement.className = 'text-sm mt-1 text-green-500';
                
                connectButton.textContent = "Connected (Live)";
                connectButton.disabled = true;
                mockButton.disabled = true;

                // Only enable logging if DB is ready
                startStopLogButton.disabled = !isAuthReady;

            } catch (error) {
                updateStatus(`GATT Error: ${error.message}. Check ESP32 NOTIFY property.`, true);
                connectButton.disabled = false;
                connectButton.textContent = "Connect to ESP32 Gauge";
                mockButton.disabled = false;
                startStopLogButton.disabled = true;
                if (bleDevice && bleDevice.gatt.connected) {
                    bleDevice.gatt.disconnect();
                }
            }
        }

        function onDisconnected() {
            updateStatus(`Device disconnected. Attempting to reconnect...`, true);
            psiValueElement.textContent = '--.-';
            connectButton.disabled = false;
            connectButton.textContent = "Connect to ESP32 Gauge";
            mockButton.disabled = false;
            startStopLogButton.disabled = true;
            if (isLogging) toggleLogging();

            setTimeout(async () => {
                 if (bleDevice) {
                    try {
                        updateStatus("Reconnecting...");
                        await connectGATT();
                    } catch (error) {
                        updateStatus(`Reconnection failed: ${error.message}`, true);
                        connectButton.disabled = false;
                        connectButton.textContent = "Connect to ESP32 Gauge";
                        mockButton.disabled = false;
                    }
                }
            }, 2000);
        }

        // --- Initialization on load ---
        window.onload = () => {
            initializeFirebase();
            psiValueElement.textContent = '--.-';
            updateStatus("Ready to connect. Tap the button or start mock data.");
        };

    </script>
</body>
</html>
